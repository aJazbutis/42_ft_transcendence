{"ast":null,"code":"import _asyncToGenerator from \"/app-frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { BehaviorSubject, Subject } from 'rxjs';\nimport { ACCEPT_MATCH, INVITE_TO_MATCH } from '../chat/subscriptions-events-constants';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../app.module\";\nfunction waitOneSecond() {\n  return _waitOneSecond.apply(this, arguments);\n}\nfunction _waitOneSecond() {\n  _waitOneSecond = _asyncToGenerator(function* () {\n    yield new Promise(resolve => setTimeout(resolve, 1000));\n    // console.log(\"...\");\n  });\n  return _waitOneSecond.apply(this, arguments);\n}\nexport let GameService = /*#__PURE__*/(() => {\n  class GameService {\n    constructor(socket) {\n      this.socket = socket;\n      this.gameInfoSubject = new Subject();\n      this.gameStatus = new BehaviorSubject(0);\n      this.gameQueue = new Subject();\n      this.difficulty = 0;\n      this.listenersOn = false;\n    }\n    getGameObservable() {\n      return this.gameInfoSubject.asObservable();\n    }\n    getStatusQueue() {\n      return this.gameQueue.asObservable();\n    }\n    getGameStatus() {\n      return this.gameStatus;\n    }\n    setGameStatus(stat) {\n      this.gameStatus.next(stat);\n    }\n    createMatchInfo(ID, level) {\n      const matchInfo = {\n        matchId: ID,\n        mode: level\n      };\n      return matchInfo;\n    }\n    createPaddleDto(value) {\n      const retValue = {\n        step: value\n      };\n      return retValue;\n    }\n    createGameDto(level) {\n      const gameMode = {\n        mode: level\n      };\n      return gameMode;\n    }\n    handlerGameInfo(msg) {\n      console.log(\"Received raw data from backend:\");\n      console.log(JSON.stringify(msg));\n      this.gameInfo = msg;\n      console.log(\"Updated gameInfo:\");\n      console.log(JSON.stringify(this.gameInfo));\n      console.log(\"Receiving game info:\" + this.gameInfo.status);\n      this.gameInfoSubject.next(this.gameInfo);\n      this.gameStatus.next(this.gameInfo.status);\n    }\n    handlerGameStart(msg) {\n      if (msg === 'Waiting players to join') {\n        console.log(\"Player in queue... Waiting for players to join\" + this.socket.ioSocket.id);\n        console.log(\"emitting true:\");\n        this.gameQueue.next(true);\n      } else {\n        this.matchInfo = msg;\n        console.log(\"emitting false:\");\n        this.gameQueue.next(false);\n        console.log(\"joining the match: \" + this.matchInfo.id);\n        this.emitJoinMatch();\n      }\n    }\n    emitPaddlePosition(movementValue) {\n      const toEmit = this.createPaddleDto(movementValue);\n      this.socket.emit('key', toEmit);\n    }\n    emitJoinMatch() {\n      const matchID = this.createMatchInfo(this.matchInfo.id, this.difficulty);\n      this.socket.emit('join', matchID);\n    }\n    emitStart(difficulty) {\n      const gameMode = this.createGameDto(difficulty);\n      this.socket.emit('start', gameMode);\n    }\n    listenersInit() {\n      console.log(\"listeners on: \" + this.listenersOn);\n      if (this.listenersOn === false) {\n        this.listenersOn = true;\n        this.socket.on('error', msg => {\n          alert('Internal Server Error');\n        });\n        this.socket.on('join', msg => {\n          console.log(JSON.stringify(msg));\n        });\n        this.socket.on('game', msg => {\n          this.handlerGameInfo(msg);\n        });\n        this.socket.on('start', msg => {\n          this.handlerGameStart(msg);\n        });\n        this.socket.on('disconnect', () => {\n          this.handleDisconnection();\n        });\n        this.socket.on('connect', () => {\n          console.log(\"CONNECTION \" + this.socket.ioSocket.id);\n        });\n      }\n    }\n    startGameService(level) {\n      this.difficulty = level;\n      this.emitStart(level);\n      console.log(\"EMiTTING START + LEVEL\");\n    }\n    handleDisconnection() {\n      // this.listenersOn = false;\n      // this.socket.removeAllListeners();\n      console.log(\"Disconnection.\");\n    }\n    handleConnection() {\n      this.listenersInit();\n    }\n    getUser() {\n      this.socket.on('user', user => {\n        this.userInfo = user;\n        console.log(\"USER: \" + user.id);\n      });\n    }\n    inviteToMatch(invitedUser, selectedMode) {\n      this.socket.emit(INVITE_TO_MATCH, {\n        userId: invitedUser,\n        mode: selectedMode\n      });\n    }\n    acceptInvite(userID, mode) {\n      this.socket.emit(ACCEPT_MATCH, {\n        userId: userID,\n        mode: mode\n      });\n    }\n    static #_ = this.ɵfac = function GameService_Factory(t) {\n      return new (t || GameService)(i0.ɵɵinject(i1.GameSocket));\n    };\n    static #_2 = this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: GameService,\n      factory: GameService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return GameService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}