{"ast":null,"code":"import { ACCEPT_PRIVATE_INVITE, ADD_ADMIN, BAN, BLOCK, CHANNELS, CHANNEL_MESSAGES, CHANNEL_USERS, CREATE, DECLINE_PRIVATE_INVITE, DIRECT, ERROR, JOIN, KICK, LEAVE, MESSAGE, MUTE, REM_ADMIN, SUCCESS, UNBAN, UNBLOCK, USER_CHANNELS } from './subscriptions-events-constants';\nimport { HOST_IP } from '../Constants';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nimport * as i2 from \"../app.module\";\nexport let ChatService = /*#__PURE__*/(() => {\n  class ChatService {\n    constructor(http, socket) {\n      this.http = http;\n      this.socket = socket;\n      this.domain = HOST_IP;\n    }\n    findUser(username) {\n      return this.http.get(`${this.domain}/user/find-by-username?username=${username}`, {\n        withCredentials: true\n      });\n    }\n    /* <---------- Socket emits ----------> */\n    requestChannels() {\n      this.socket.emit(CHANNELS);\n    }\n    requestUserChannels() {\n      this.socket.emit(USER_CHANNELS);\n    }\n    requestChannelUsers(channelID) {\n      this.socket.emit(CHANNEL_USERS, {\n        cId: channelID\n      });\n    }\n    createChannel(channelInfo) {\n      this.socket.emit(CREATE, channelInfo);\n    }\n    joinChannel(joinInfo) {\n      this.socket.emit(JOIN, joinInfo);\n    }\n    acceptPrivateInvite(channelID, msgID) {\n      this.socket.emit(ACCEPT_PRIVATE_INVITE, {\n        cId: Number(channelID),\n        msgId: msgID\n      });\n    }\n    declineChannelInvite(channelID, msgID) {\n      this.socket.emit(DECLINE_PRIVATE_INVITE, {\n        cId: Number(channelID),\n        msgId: msgID\n      });\n    }\n    leaveChannel(joinInfo) {\n      this.socket.emit(LEAVE, joinInfo);\n    }\n    sendMessage(channelID, message) {\n      this.socket.emit(MESSAGE, {\n        cId: channelID,\n        content: message\n      });\n    }\n    requestChannelMessages(channelID) {\n      this.socket.emit(CHANNEL_MESSAGES, {\n        cId: channelID\n      });\n    }\n    exitChannel(channelID) {\n      this.socket.emit(LEAVE, {\n        cId: channelID\n      });\n    }\n    // Communication problem. inviteId is actually either the invite to private channel or a game mode\n    sendDM(userID, message, inviteType, inviteId) {\n      this.socket.emit(DIRECT, {\n        uId: userID,\n        text: message,\n        inviteType: inviteType,\n        inviteId: inviteId\n      });\n    }\n    manageUserModeration(action, userID, channelID) {\n      switch (action) {\n        case BLOCK:\n          this.socket.emit(BLOCK, {\n            uId: userID\n          });\n          break;\n        case UNBLOCK:\n          this.socket.emit(UNBLOCK, {\n            uId: userID\n          });\n          break;\n        case MUTE:\n          this.socket.emit(MUTE, {\n            cId: channelID,\n            uId: userID\n          });\n          break;\n        case BAN:\n          this.socket.emit(BAN, {\n            cId: channelID,\n            uId: userID\n          });\n          break;\n        case UNBAN:\n          this.socket.emit(UNBAN, {\n            cId: channelID,\n            uId: userID\n          });\n          break;\n        case KICK:\n          this.socket.emit(KICK, {\n            cId: channelID,\n            uId: userID\n          });\n          break;\n        case ADD_ADMIN:\n          this.socket.emit(ADD_ADMIN, {\n            cId: channelID,\n            uId: userID\n          });\n          break;\n        case REM_ADMIN:\n          this.socket.emit(REM_ADMIN, {\n            cId: channelID,\n            uId: userID\n          });\n          break;\n        default:\n          break;\n      }\n    }\n    /* <---------- Events to listen to ----------> */\n    onError() {\n      return this.socket.fromEvent(ERROR);\n    }\n    onSuccess() {\n      this.socket.on(SUCCESS, msg => {\n        console.log(msg);\n      });\n    }\n    getUsersChannels() {\n      return this.socket.fromEvent(USER_CHANNELS);\n    }\n    getChannels() {\n      return this.socket.fromEvent(CHANNELS);\n    }\n    getChannelUsers() {\n      return this.socket.fromEvent(CHANNEL_USERS);\n    }\n    getChannelMessages() {\n      return this.socket.fromEvent(CHANNEL_MESSAGES);\n    }\n    getIncomingMessages() {\n      return this.socket.fromEvent(MESSAGE);\n    }\n    static #_ = this.ɵfac = function ChatService_Factory(t) {\n      return new (t || ChatService)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(i2.ChatSocket));\n    };\n    static #_2 = this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: ChatService,\n      factory: ChatService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return ChatService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}